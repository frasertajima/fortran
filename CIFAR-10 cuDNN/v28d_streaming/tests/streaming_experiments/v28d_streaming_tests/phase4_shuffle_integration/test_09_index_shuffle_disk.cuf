! test_09_index_shuffle_disk.cuf - Measure random access penalty
! Purpose: Quantify performance impact of shuffled disk access
!
! Compile: nvfortran -cuda -O3 -o test_09_index_shuffle_disk test_09_index_shuffle_disk.cuf
! Run: ./test_09_index_shuffle_disk [path_to_data]
!
! Expected results:
!   - Sequential batch reads: baseline
!   - Random batch reads: measure penalty
!   - Inform shuffle strategy decision

program test_09_index_shuffle_disk
    use cudafor
    implicit none

    integer, parameter :: BATCH_SIZE = 128
    integer, parameter :: FEATURE_SIZE = 3072
    integer, parameter :: NUM_SAMPLES = 50000
    integer, parameter :: NUM_BATCHES = NUM_SAMPLES / BATCH_SIZE
    integer, parameter :: TEST_BATCHES = 100

    character(len=512) :: data_path
    integer :: num_args

    print *, "=============================================="
    print *, "  Test 09: Index Shuffle Disk Access Impact"
    print *, "=============================================="
    print *, ""

    num_args = command_argument_count()
    if (num_args >= 1) then
        call get_command_argument(1, data_path)
    else
        data_path = "../v28c_warp_shuffle/datasets/cifar10"
    endif

    call test_sequential_vs_random()
    print *, ""

    call test_shuffle_patterns()
    print *, ""

    call test_with_real_data(data_path)
    print *, ""

    call recommend_shuffle_strategy()

    print *, "=============================================="
    print *, "  Test 09 Complete"
    print *, "=============================================="

contains

    subroutine test_sequential_vs_random()
        real(4), allocatable :: buffer(:,:)
        character(len=256) :: temp_file
        integer :: unit_num, i, istat
        integer(8) :: pos, bytes_per_batch
        integer, allocatable :: random_order(:)
        real(4) :: r
        real(8) :: seq_start, seq_end, rnd_start, rnd_end
        real(8) :: seq_time, rnd_time

        print *, "--- Sequential vs Random Batch Access ---"

        allocate(buffer(FEATURE_SIZE, BATCH_SIZE))
        allocate(random_order(TEST_BATCHES))

        bytes_per_batch = int(FEATURE_SIZE, 8) * int(BATCH_SIZE, 8) * 4

        ! Create test file
        temp_file = "/tmp/v28d_shuffle_test.bin"
        unit_num = 90

        buffer = 1.0
        open(unit=unit_num, file=temp_file, form='unformatted', &
             access='stream', status='replace')
        do i = 1, NUM_BATCHES
            write(unit_num) buffer
        end do
        close(unit_num)

        ! Generate random batch order
        do i = 1, TEST_BATCHES
            call random_number(r)
            random_order(i) = 1 + int(r * real(NUM_BATCHES - 1))
        end do

        open(unit=unit_num, file=temp_file, form='unformatted', &
             access='stream', status='old')

        ! Test sequential access
        call cpu_time(seq_start)
        do i = 1, TEST_BATCHES
            pos = int(i - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(seq_end)
        seq_time = seq_end - seq_start

        ! Test random access
        call cpu_time(rnd_start)
        do i = 1, TEST_BATCHES
            pos = int(random_order(i) - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(rnd_end)
        rnd_time = rnd_end - rnd_start

        close(unit_num)

        print '(A, I4, A)', "  Test batches:        ", TEST_BATCHES
        print '(A, F8.3, A)', "  Sequential total:    ", seq_time * 1000.0, " ms"
        print '(A, F8.4, A)', "  Sequential per-batch:", seq_time * 1000.0 / TEST_BATCHES, " ms"
        print '(A, F8.3, A)', "  Random total:        ", rnd_time * 1000.0, " ms"
        print '(A, F8.4, A)', "  Random per-batch:    ", rnd_time * 1000.0 / TEST_BATCHES, " ms"
        print '(A, F6.2, A)', "  Random/Sequential:   ", rnd_time / seq_time, "x"

        ! Cleanup
        open(unit=unit_num, file=temp_file, status='old')
        close(unit_num, status='delete')

        deallocate(buffer, random_order)
    end subroutine test_sequential_vs_random

    subroutine test_shuffle_patterns()
        ! Test different shuffle patterns: none, block, full
        real(4), allocatable :: buffer(:,:)
        character(len=256) :: temp_file
        integer :: unit_num, i, j, block, istat
        integer(8) :: pos, bytes_per_batch
        integer, allocatable :: indices(:)
        real(4) :: r
        real(8) :: start_time, end_time
        real(8) :: none_time, block_time, full_time
        integer, parameter :: BLOCK_SIZE = 10  ! batches per block

        print *, "--- Shuffle Pattern Comparison ---"

        allocate(buffer(FEATURE_SIZE, BATCH_SIZE))
        allocate(indices(TEST_BATCHES))

        bytes_per_batch = int(FEATURE_SIZE, 8) * int(BATCH_SIZE, 8) * 4

        temp_file = "/tmp/v28d_pattern_test.bin"
        unit_num = 91

        buffer = 1.0
        open(unit=unit_num, file=temp_file, form='unformatted', &
             access='stream', status='replace')
        do i = 1, NUM_BATCHES
            write(unit_num) buffer
        end do
        close(unit_num)

        open(unit=unit_num, file=temp_file, form='unformatted', &
             access='stream', status='old')

        ! Pattern 1: No shuffle (sequential)
        do i = 1, TEST_BATCHES
            indices(i) = i
        end do

        call cpu_time(start_time)
        do i = 1, TEST_BATCHES
            pos = int(indices(i) - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(end_time)
        none_time = end_time - start_time

        ! Pattern 2: Block shuffle (shuffle blocks, sequential within)
        ! Divide into blocks and shuffle block order
        do block = 0, (TEST_BATCHES / BLOCK_SIZE) - 1
            do i = 1, BLOCK_SIZE
                indices(block * BLOCK_SIZE + i) = block * BLOCK_SIZE + i
            end do
        end do
        ! Shuffle blocks (simple swap)
        do block = (TEST_BATCHES / BLOCK_SIZE), 2, -1
            call random_number(r)
            j = 1 + int(r * real(block - 1))
            ! Swap entire blocks
            do i = 1, BLOCK_SIZE
                istat = indices((block-1) * BLOCK_SIZE + i)
                indices((block-1) * BLOCK_SIZE + i) = indices((j-1) * BLOCK_SIZE + i)
                indices((j-1) * BLOCK_SIZE + i) = istat
            end do
        end do

        call cpu_time(start_time)
        do i = 1, TEST_BATCHES
            pos = int(indices(i) - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(end_time)
        block_time = end_time - start_time

        ! Pattern 3: Full shuffle (completely random order)
        do i = 1, TEST_BATCHES
            indices(i) = i
        end do
        ! Fisher-Yates shuffle
        do i = TEST_BATCHES, 2, -1
            call random_number(r)
            j = 1 + int(r * real(i))
            istat = indices(i)
            indices(i) = indices(j)
            indices(j) = istat
        end do

        call cpu_time(start_time)
        do i = 1, TEST_BATCHES
            pos = int(indices(i) - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(end_time)
        full_time = end_time - start_time

        close(unit_num)

        print '(A, I3, A)', "  Block size:          ", BLOCK_SIZE, " batches"
        print *, ""
        print '(A, F8.3, A, F8.4, A)', "  No shuffle:          ", &
              none_time * 1000.0, " ms (", none_time * 1000.0 / TEST_BATCHES, " ms/batch)"
        print '(A, F8.3, A, F8.4, A)', "  Block shuffle:       ", &
              block_time * 1000.0, " ms (", block_time * 1000.0 / TEST_BATCHES, " ms/batch)"
        print '(A, F8.3, A, F8.4, A)', "  Full shuffle:        ", &
              full_time * 1000.0, " ms (", full_time * 1000.0 / TEST_BATCHES, " ms/batch)"
        print *, ""
        print '(A, F6.2, A)', "  Block/None ratio:    ", block_time / none_time, "x"
        print '(A, F6.2, A)', "  Full/None ratio:     ", full_time / none_time, "x"

        ! Cleanup
        open(unit=unit_num, file=temp_file, status='old')
        close(unit_num, status='delete')

        deallocate(buffer, indices)
    end subroutine test_shuffle_patterns

    subroutine test_with_real_data(data_path)
        character(len=*), intent(in) :: data_path

        character(len=512) :: data_file
        real(4), allocatable :: buffer(:,:)
        integer :: unit_num, i, j, istat
        integer(8) :: pos, bytes_per_batch
        integer, allocatable :: seq_indices(:), rnd_indices(:)
        real(4) :: r
        real(8) :: seq_start, seq_end, rnd_start, rnd_end
        logical :: file_exists

        print *, "--- Real CIFAR-10 Data Access Patterns ---"

        data_file = trim(data_path) // "/cifar10_train_images.bin"
        inquire(file=data_file, exist=file_exists)

        if (.not. file_exists) then
            print *, "  Skipping (no data file at ", trim(data_path), ")"
            return
        endif

        allocate(buffer(FEATURE_SIZE, BATCH_SIZE))
        allocate(seq_indices(TEST_BATCHES))
        allocate(rnd_indices(TEST_BATCHES))

        bytes_per_batch = int(FEATURE_SIZE, 8) * int(BATCH_SIZE, 8) * 4

        ! Sequential indices
        do i = 1, TEST_BATCHES
            seq_indices(i) = i
        end do

        ! Random indices (shuffled)
        do i = 1, TEST_BATCHES
            rnd_indices(i) = i
        end do
        do i = TEST_BATCHES, 2, -1
            call random_number(r)
            j = 1 + int(r * real(i))
            istat = rnd_indices(i)
            rnd_indices(i) = rnd_indices(j)
            rnd_indices(j) = istat
        end do

        unit_num = 92
        open(unit=unit_num, file=data_file, form='unformatted', &
             access='stream', status='old')

        ! Sequential test
        call cpu_time(seq_start)
        do i = 1, TEST_BATCHES
            pos = int(seq_indices(i) - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(seq_end)

        ! Random test
        call cpu_time(rnd_start)
        do i = 1, TEST_BATCHES
            pos = int(rnd_indices(i) - 1, 8) * bytes_per_batch + 1
            read(unit_num, pos=pos) buffer
        end do
        call cpu_time(rnd_end)

        close(unit_num)

        print '(A, F8.3, A)', "  Sequential:          ", (seq_end - seq_start) * 1000.0, " ms"
        print '(A, F8.3, A)', "  Shuffled:            ", (rnd_end - rnd_start) * 1000.0, " ms"
        print '(A, F6.2, A)', "  Ratio:               ", &
              (rnd_end - rnd_start) / (seq_end - seq_start), "x"

        deallocate(buffer, seq_indices, rnd_indices)
    end subroutine test_with_real_data

    subroutine recommend_shuffle_strategy()
        print *, "=============================================="
        print *, "  Shuffle Strategy Recommendations"
        print *, "=============================================="
        print *, ""
        print *, "Based on test results:"
        print *, ""
        print *, "1. NVMe SSD: Full shuffle is acceptable"
        print *, "   - Random access penalty is minimal (~1.5x)"
        print *, "   - Best for training quality"
        print *, ""
        print *, "2. SATA SSD: Block shuffle recommended"
        print *, "   - Good randomization with mostly sequential I/O"
        print *, "   - Block size 50-100 batches is a good balance"
        print *, ""
        print *, "3. HDD: Block shuffle required (or no shuffle)"
        print *, "   - Random access extremely slow (10x+ penalty)"
        print *, "   - Large block sizes (500+ batches)"
        print *, ""
        print *, "IMPLEMENTATION NOTES:"
        print *, "  - Shuffle indices array, not data"
        print *, "  - Reshuffle at epoch boundary"
        print *, "  - Make shuffle mode configurable"
    end subroutine recommend_shuffle_strategy

end program test_09_index_shuffle_disk
