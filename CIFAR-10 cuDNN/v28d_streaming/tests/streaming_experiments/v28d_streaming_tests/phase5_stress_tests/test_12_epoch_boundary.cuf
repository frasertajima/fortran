! test_12_epoch_boundary.cuf - Validate epoch transition handling
! Purpose: Test correct behavior at epoch boundaries
!
! Compile: nvfortran -cuda -mp -O3 -o test_12_epoch_boundary test_12_epoch_boundary.cuf
! Run: OMP_NUM_THREADS=2 ./test_12_epoch_boundary
!
! Expected results:
!   - Correct batch count per epoch
!   - Clean reshuffle between epochs
!   - No hangs or data loss at boundaries

program test_12_epoch_boundary
    use cudafor
    use omp_lib
    implicit none

    integer, parameter :: BATCH_SIZE = 128
    integer, parameter :: FEATURE_SIZE = 3072
    integer, parameter :: NUM_SAMPLES = 1000      ! Small for testing
    integer, parameter :: NUM_BATCHES = NUM_SAMPLES / BATCH_SIZE
    integer, parameter :: NUM_EPOCHS = 5

    print *, "=============================================="
    print *, "  Test 12: Epoch Boundary Handling"
    print *, "=============================================="
    print *, ""
    print *, "Samples:", NUM_SAMPLES
    print *, "Batch size:", BATCH_SIZE
    print *, "Batches per epoch:", NUM_BATCHES
    print *, "Test epochs:", NUM_EPOCHS
    print *, ""

    call test_epoch_batch_count()
    print *, ""

    call test_reshuffle_between_epochs()
    print *, ""

    call test_double_buffer_epoch_transition()
    print *, ""

    call test_sample_coverage_per_epoch()
    print *, ""

    print *, "=============================================="
    print *, "  Test 12 Complete"
    print *, "=============================================="

contains

    subroutine test_epoch_batch_count()
        real(4), allocatable :: buffer(:,:)
        character(len=256) :: temp_file
        integer :: unit_num, epoch, batch, batch_count
        integer :: total_batches
        integer(8) :: pos, bytes_per_batch

        print *, "--- Epoch Batch Count Test ---"

        allocate(buffer(FEATURE_SIZE, BATCH_SIZE))
        bytes_per_batch = int(FEATURE_SIZE, 8) * int(BATCH_SIZE, 8) * 4

        ! Create test file
        temp_file = "/tmp/v28d_epoch_test.bin"
        unit_num = 120

        buffer = 1.0
        open(unit=unit_num, file=temp_file, form='unformatted', &
             access='stream', status='replace')
        do batch = 1, NUM_BATCHES
            write(unit_num) buffer
        end do
        close(unit_num)

        total_batches = 0

        do epoch = 1, NUM_EPOCHS
            batch_count = 0

            open(unit=unit_num, file=temp_file, form='unformatted', &
                 access='stream', status='old')

            do batch = 1, NUM_BATCHES
                pos = int(batch - 1, 8) * bytes_per_batch + 1
                read(unit_num, pos=pos) buffer
                batch_count = batch_count + 1
            end do

            close(unit_num)

            total_batches = total_batches + batch_count

            if (batch_count == NUM_BATCHES) then
                print '(A, I2, A, I4, A)', "  Epoch ", epoch, ": ", batch_count, " batches - PASS"
            else
                print '(A, I2, A, I4, A, I4, A)', "  Epoch ", epoch, ": ", batch_count, &
                      " batches (expected ", NUM_BATCHES, ") - FAIL"
            endif
        end do

        print '(A, I6)', "  Total batches:       ", total_batches
        print '(A, I6)', "  Expected:            ", NUM_EPOCHS * NUM_BATCHES

        if (total_batches == NUM_EPOCHS * NUM_BATCHES) then
            print *, "  Overall:             PASS"
        else
            print *, "  Overall:             FAIL"
        endif

        ! Cleanup
        open(unit=unit_num, file=temp_file, status='old')
        close(unit_num, status='delete')

        deallocate(buffer)
    end subroutine test_epoch_batch_count

    subroutine test_reshuffle_between_epochs()
        integer, allocatable :: indices(:), prev_indices(:)
        integer :: epoch, i, j, temp, same_count
        real(4) :: r

        print *, "--- Reshuffle Between Epochs Test ---"

        allocate(indices(NUM_BATCHES))
        allocate(prev_indices(NUM_BATCHES))

        ! Initialize
        do i = 1, NUM_BATCHES
            indices(i) = i
            prev_indices(i) = i
        end do

        do epoch = 1, NUM_EPOCHS
            ! Shuffle (Fisher-Yates)
            do i = NUM_BATCHES, 2, -1
                call random_number(r)
                j = 1 + int(r * real(i))
                temp = indices(i)
                indices(i) = indices(j)
                indices(j) = temp
            end do

            ! Count how many indices stayed in same position
            same_count = 0
            do i = 1, NUM_BATCHES
                if (indices(i) == prev_indices(i)) same_count = same_count + 1
            end do

            print '(A, I2, A, I4, A, I4, A, F5.1, A)', &
                  "  Epoch ", epoch, ": ", same_count, "/", NUM_BATCHES, &
                  " same position (", 100.0 * real(same_count) / NUM_BATCHES, "%)"

            ! Save for next comparison
            prev_indices = indices
        end do

        print *, "  Reshuffle working:   PASS (indices change each epoch)"

        deallocate(indices, prev_indices)
    end subroutine test_reshuffle_between_epochs

    subroutine test_double_buffer_epoch_transition()
        ! Test that double buffer handles epoch boundary correctly
        type :: buffer_t
            real(4), managed, allocatable :: data(:,:)
            integer :: batch_idx
            logical :: ready
        end type buffer_t

        type(buffer_t), target :: buffer_a, buffer_b
        type(buffer_t), pointer :: current_buf, loading_buf, temp_ptr
        character(len=256) :: temp_file
        integer :: unit_num, epoch, batch, istat
        integer(8) :: pos, bytes_per_batch
        integer :: batches_processed, total_processed

        print *, "--- Double Buffer Epoch Transition ---"

        allocate(buffer_a%data(FEATURE_SIZE, BATCH_SIZE))
        allocate(buffer_b%data(FEATURE_SIZE, BATCH_SIZE))

        bytes_per_batch = int(FEATURE_SIZE, 8) * int(BATCH_SIZE, 8) * 4

        ! Create test file
        temp_file = "/tmp/v28d_double_epoch.bin"
        unit_num = 121

        buffer_a%data = 1.0
        open(unit=unit_num, file=temp_file, form='unformatted', &
             access='stream', status='replace')
        do batch = 1, NUM_BATCHES
            write(unit_num) buffer_a%data
        end do
        close(unit_num)

        total_processed = 0

        do epoch = 1, NUM_EPOCHS
            batches_processed = 0

            current_buf => buffer_a
            loading_buf => buffer_b
            current_buf%ready = .false.
            loading_buf%ready = .false.

            open(unit=unit_num, file=temp_file, form='unformatted', &
                 access='stream', status='old')

            ! Pre-load first batch
            read(unit_num) current_buf%data
            current_buf%batch_idx = 1
            current_buf%ready = .true.

            do batch = 1, NUM_BATCHES
                ! Process current batch
                if (.not. current_buf%ready) then
                    print *, "  ERROR: Buffer not ready at batch", batch
                    exit
                endif

                batches_processed = batches_processed + 1

                ! Load next batch if not at end
                if (batch < NUM_BATCHES) then
                    pos = int(batch, 8) * bytes_per_batch + 1
                    read(unit_num, pos=pos) loading_buf%data
                    loading_buf%batch_idx = batch + 1
                    loading_buf%ready = .true.
                endif

                ! Swap
                temp_ptr => current_buf
                current_buf => loading_buf
                loading_buf => temp_ptr
                loading_buf%ready = .false.
            end do

            close(unit_num)

            total_processed = total_processed + batches_processed

            if (batches_processed == NUM_BATCHES) then
                print '(A, I2, A)', "  Epoch ", epoch, ": transition OK"
            else
                print '(A, I2, A, I4, A)', "  Epoch ", epoch, ": FAIL (only ", &
                      batches_processed, " batches)"
            endif
        end do

        print '(A, I6)', "  Total processed:     ", total_processed

        if (total_processed == NUM_EPOCHS * NUM_BATCHES) then
            print *, "  Epoch transitions:   PASS"
        else
            print *, "  Epoch transitions:   FAIL"
        endif

        ! Cleanup
        open(unit=unit_num, file=temp_file, status='old')
        close(unit_num, status='delete')

        deallocate(buffer_a%data, buffer_b%data)
    end subroutine test_double_buffer_epoch_transition

    subroutine test_sample_coverage_per_epoch()
        ! Verify every sample is seen exactly once per epoch
        integer, allocatable :: sample_seen(:)
        integer, allocatable :: indices(:)
        integer :: epoch, batch, sample_idx, i, j, temp
        integer :: missing, duplicates
        real(4) :: r

        print *, "--- Sample Coverage Per Epoch ---"

        allocate(sample_seen(NUM_SAMPLES))
        allocate(indices(NUM_SAMPLES))

        do epoch = 1, 3  ! Test 3 epochs
            sample_seen = 0

            ! Initialize indices
            do i = 1, NUM_SAMPLES
                indices(i) = i
            end do

            ! Shuffle
            do i = NUM_SAMPLES, 2, -1
                call random_number(r)
                j = 1 + int(r * real(i))
                temp = indices(i)
                indices(i) = indices(j)
                indices(j) = temp
            end do

            ! Simulate epoch: mark each sample as seen
            do batch = 1, NUM_BATCHES
                do i = 1, BATCH_SIZE
                    sample_idx = indices((batch - 1) * BATCH_SIZE + i)
                    sample_seen(sample_idx) = sample_seen(sample_idx) + 1
                end do
            end do

            ! Count missing and duplicates
            missing = 0
            duplicates = 0
            do i = 1, NUM_SAMPLES
                if (sample_seen(i) == 0) missing = missing + 1
                if (sample_seen(i) > 1) duplicates = duplicates + 1
            end do

            if (missing == 0 .and. duplicates == 0) then
                print '(A, I2, A)', "  Epoch ", epoch, ": All samples seen exactly once - PASS"
            else
                print '(A, I2, A, I4, A, I4, A)', "  Epoch ", epoch, &
                      ": missing=", missing, " duplicates=", duplicates, " - FAIL"
            endif
        end do

        deallocate(sample_seen, indices)
    end subroutine test_sample_coverage_per_epoch

end program test_12_epoch_boundary
