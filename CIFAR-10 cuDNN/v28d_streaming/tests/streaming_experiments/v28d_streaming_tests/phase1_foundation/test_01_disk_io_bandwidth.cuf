! test_01_disk_io_bandwidth.cuf - Measure raw disk I/O performance
! Purpose: Validate design assumptions about disk read speeds
!
! Compile: nvfortran -cuda -O3 -o test_01_disk_io_bandwidth test_01_disk_io_bandwidth.cuf
! Run: ./test_01_disk_io_bandwidth
!
! Expected results (NVMe SSD):
!   - Sequential read: 2000-5000 MB/s
!   - Random 4KB: < 0.5 ms
!   - Batch-sized read (0.5MB): < 0.5 ms

program test_01_disk_io_bandwidth
    use cudafor
    implicit none

    ! Test parameters
    integer, parameter :: TEST_FILE_SIZE_MB = 512     ! Create 512MB test file
    integer, parameter :: BATCH_SIZE = 128
    integer, parameter :: FEATURE_SIZE = 3072         ! CIFAR-10: 32x32x3
    integer, parameter :: BYTES_PER_BATCH = BATCH_SIZE * FEATURE_SIZE * 4  ! ~1.5MB
    integer, parameter :: NUM_SEQUENTIAL_READS = 100
    integer, parameter :: NUM_RANDOM_READS = 100
    integer, parameter :: SMALL_READ_SIZE = 4096      ! 4KB
    integer, parameter :: MEDIUM_READ_SIZE = 65536    ! 64KB
    integer, parameter :: LARGE_READ_SIZE = 1048576   ! 1MB

    character(len=256) :: test_filename
    integer :: file_unit = 20
    integer :: istat
    logical :: file_exists

    print *, "=============================================="
    print *, "  Test 01: Disk I/O Bandwidth Measurement"
    print *, "=============================================="
    print *, ""

    ! Use a temporary test file
    test_filename = "/tmp/v28d_io_test.bin"

    ! Create test file if needed
    call create_test_file(test_filename, TEST_FILE_SIZE_MB)

    print *, "Test file:", trim(test_filename)
    print *, "Test file size:", TEST_FILE_SIZE_MB, "MB"
    print *, ""

    ! Run tests
    print *, "--- Sequential Read Tests ---"
    call test_sequential_read(test_filename, SMALL_READ_SIZE, "4KB blocks")
    call test_sequential_read(test_filename, MEDIUM_READ_SIZE, "64KB blocks")
    call test_sequential_read(test_filename, LARGE_READ_SIZE, "1MB blocks")
    call test_sequential_read(test_filename, BYTES_PER_BATCH, "Batch-sized (1.5MB)")
    print *, ""

    print *, "--- Random Access Tests ---"
    call test_random_access(test_filename, SMALL_READ_SIZE, "4KB random")
    call test_random_access(test_filename, MEDIUM_READ_SIZE, "64KB random")
    call test_random_access(test_filename, BYTES_PER_BATCH, "Batch-sized random")
    print *, ""

    print *, "--- Batch Simulation Test ---"
    call test_batch_read_pattern(test_filename)
    print *, ""

    ! Cleanup
    call delete_test_file(test_filename)

    print *, "=============================================="
    print *, "  Test 01 Complete"
    print *, "=============================================="

contains

    subroutine create_test_file(filename, size_mb)
        character(len=*), intent(in) :: filename
        integer, intent(in) :: size_mb

        integer, parameter :: CHUNK_SIZE = 1048576  ! 1MB chunks
        real(4), allocatable :: buffer(:)
        integer :: i, num_chunks, unit_num
        logical :: exists

        inquire(file=filename, exist=exists)
        if (exists) then
            print *, "  Test file already exists, reusing..."
            return
        endif

        print *, "  Creating test file (", size_mb, "MB)..."

        allocate(buffer(CHUNK_SIZE / 4))  ! float = 4 bytes

        ! Initialize with random-ish data
        do i = 1, size(buffer)
            buffer(i) = real(mod(i * 17 + 31, 256)) / 255.0
        end do

        unit_num = 30
        open(unit=unit_num, file=filename, form='unformatted', &
             access='stream', status='replace', iostat=istat)

        if (istat /= 0) then
            print *, "  ERROR: Cannot create test file"
            stop 1
        endif

        num_chunks = size_mb
        do i = 1, num_chunks
            write(unit_num) buffer
        end do

        close(unit_num)
        deallocate(buffer)

        print *, "  Test file created successfully"
    end subroutine create_test_file

    subroutine delete_test_file(filename)
        character(len=*), intent(in) :: filename
        integer :: unit_num
        logical :: exists

        inquire(file=filename, exist=exists)
        if (exists) then
            unit_num = 30
            open(unit=unit_num, file=filename, status='old')
            close(unit_num, status='delete')
            print *, "  Test file deleted"
        endif
    end subroutine delete_test_file

    subroutine test_sequential_read(filename, read_size, description)
        character(len=*), intent(in) :: filename, description
        integer, intent(in) :: read_size

        integer(1), allocatable :: buffer(:)
        integer :: unit_num, i, num_reads
        integer(8) :: file_size, total_bytes
        real(8) :: start_time, end_time, elapsed, bandwidth_mbs

        allocate(buffer(read_size))
        unit_num = 31

        ! Get file size
        inquire(file=filename, size=file_size)
        num_reads = min(NUM_SEQUENTIAL_READS, int(file_size / read_size))
        total_bytes = int(num_reads, 8) * int(read_size, 8)

        open(unit=unit_num, file=filename, form='unformatted', &
             access='stream', status='old', iostat=istat)

        ! Warm up
        read(unit_num) buffer
        rewind(unit_num)

        ! Timed sequential reads
        call cpu_time(start_time)

        do i = 1, num_reads
            read(unit_num, iostat=istat) buffer
            if (istat /= 0) exit
        end do

        call cpu_time(end_time)
        close(unit_num)

        elapsed = end_time - start_time
        if (elapsed > 0.0) then
            bandwidth_mbs = real(total_bytes, 8) / (elapsed * 1024.0 * 1024.0)
        else
            bandwidth_mbs = 0.0
        endif

        print '(A, A20, A, F10.2, A, F8.3, A)', "  ", description, ": ", &
              bandwidth_mbs, " MB/s (", elapsed * 1000.0, " ms total)"

        deallocate(buffer)
    end subroutine test_sequential_read

    subroutine test_random_access(filename, read_size, description)
        character(len=*), intent(in) :: filename, description
        integer, intent(in) :: read_size

        integer(1), allocatable :: buffer(:)
        integer :: unit_num, i
        integer(8) :: file_size, pos, max_pos
        real(4) :: r
        real(8) :: start_time, end_time, elapsed, avg_latency_ms

        allocate(buffer(read_size))
        unit_num = 32

        inquire(file=filename, size=file_size)
        max_pos = file_size - read_size

        open(unit=unit_num, file=filename, form='unformatted', &
             access='stream', status='old', iostat=istat)

        ! Warm up with a few random reads
        do i = 1, 5
            call random_number(r)
            pos = 1 + int(r * real(max_pos))
            read(unit_num, pos=pos, iostat=istat) buffer
        end do

        ! Timed random reads
        call cpu_time(start_time)

        do i = 1, NUM_RANDOM_READS
            call random_number(r)
            pos = 1 + int(r * real(max_pos))
            read(unit_num, pos=pos, iostat=istat) buffer
        end do

        call cpu_time(end_time)
        close(unit_num)

        elapsed = end_time - start_time
        avg_latency_ms = (elapsed * 1000.0) / real(NUM_RANDOM_READS)

        print '(A, A20, A, F10.4, A, I4, A)', "  ", description, ": ", &
              avg_latency_ms, " ms avg latency (", NUM_RANDOM_READS, " reads)"

        deallocate(buffer)
    end subroutine test_random_access

    subroutine test_batch_read_pattern(filename)
        character(len=*), intent(in) :: filename

        real(4), allocatable :: batch_buffer(:,:)
        integer :: unit_num, i, num_batches
        integer(8) :: file_size, pos
        real(8) :: start_time, end_time, elapsed
        real(8) :: total_time_seq, total_time_rnd
        real(4) :: r

        allocate(batch_buffer(FEATURE_SIZE, BATCH_SIZE))
        unit_num = 33

        inquire(file=filename, size=file_size)
        num_batches = min(50, int(file_size / BYTES_PER_BATCH))

        print *, "  Simulating batch reads (", num_batches, " batches, ", &
                 BYTES_PER_BATCH/1024, " KB each)"

        open(unit=unit_num, file=filename, form='unformatted', &
             access='stream', status='old', iostat=istat)

        ! Sequential batch reads
        rewind(unit_num)
        call cpu_time(start_time)
        do i = 1, num_batches
            read(unit_num, iostat=istat) batch_buffer
        end do
        call cpu_time(end_time)
        total_time_seq = end_time - start_time

        ! Random batch reads (simulating shuffled access)
        call cpu_time(start_time)
        do i = 1, num_batches
            call random_number(r)
            pos = 1 + int(r * real(file_size - BYTES_PER_BATCH))
            ! Align to batch boundary
            pos = ((pos - 1) / BYTES_PER_BATCH) * BYTES_PER_BATCH + 1
            read(unit_num, pos=pos, iostat=istat) batch_buffer
        end do
        call cpu_time(end_time)
        total_time_rnd = end_time - start_time

        close(unit_num)

        print '(A, F8.3, A, F8.4, A)', "    Sequential: ", &
              total_time_seq * 1000.0, " ms total, ", &
              (total_time_seq * 1000.0) / num_batches, " ms/batch"

        print '(A, F8.3, A, F8.4, A)', "    Random:     ", &
              total_time_rnd * 1000.0, " ms total, ", &
              (total_time_rnd * 1000.0) / num_batches, " ms/batch"

        print '(A, F6.2, A)', "    Random/Sequential ratio: ", &
              total_time_rnd / total_time_seq, "x"

        deallocate(batch_buffer)
    end subroutine test_batch_read_pattern

end program test_01_disk_io_bandwidth
