! test_02_buffer_allocation.cuf - Validate managed memory buffer allocation
! Purpose: Test double buffer allocation patterns for streaming
!
! Compile: nvfortran -cuda -O3 -o test_02_buffer_allocation test_02_buffer_allocation.cuf
! Run: ./test_02_buffer_allocation
!
! Expected results:
!   - Allocation time: < 1 ms per buffer
!   - Memory overhead: < 5% above theoretical
!   - No memory leaks after repeated cycles

program test_02_buffer_allocation
    use cudafor
    implicit none

    ! Buffer parameters matching v28d design
    integer, parameter :: BATCH_SIZE = 128
    integer, parameter :: FEATURE_SIZE = 3072         ! CIFAR-10: 32x32x3
    integer, parameter :: BYTES_PER_BUFFER = BATCH_SIZE * FEATURE_SIZE * 4
    integer, parameter :: NUM_ALLOC_CYCLES = 100

    print *, "=============================================="
    print *, "  Test 02: Buffer Allocation Patterns"
    print *, "=============================================="
    print *, ""
    print *, "Buffer configuration:"
    print *, "  Batch size:     ", BATCH_SIZE
    print *, "  Feature size:   ", FEATURE_SIZE
    print *, "  Bytes/buffer:   ", BYTES_PER_BUFFER, " (", &
             real(BYTES_PER_BUFFER)/(1024.0*1024.0), " MB)"
    print *, ""

    ! Run tests
    call test_managed_allocation()
    print *, ""

    call test_device_allocation()
    print *, ""

    call test_pinned_allocation()
    print *, ""

    call test_allocation_cycles()
    print *, ""

    call test_double_buffer_pattern()
    print *, ""

    print *, "=============================================="
    print *, "  Test 02 Complete"
    print *, "=============================================="

contains

    subroutine test_managed_allocation()
        real(4), managed, allocatable :: buffer_a(:,:)
        real(4), managed, allocatable :: buffer_b(:,:)
        integer, managed, allocatable :: labels_a(:)
        integer, managed, allocatable :: labels_b(:)
        real(8) :: start_time, end_time, alloc_time
        integer :: istat, i, j
        integer(8) :: free_before, free_after, total_mem

        print *, "--- Managed Memory Allocation ---"

        istat = cudaMemGetInfo(free_before, total_mem)

        call cpu_time(start_time)

        allocate(buffer_a(FEATURE_SIZE, BATCH_SIZE), stat=istat)
        allocate(buffer_b(FEATURE_SIZE, BATCH_SIZE), stat=istat)
        allocate(labels_a(BATCH_SIZE), stat=istat)
        allocate(labels_b(BATCH_SIZE), stat=istat)

        call cpu_time(end_time)

        if (istat /= 0) then
            print *, "  FAILED: Allocation error"
            return
        endif

        istat = cudaMemGetInfo(free_after, total_mem)

        alloc_time = (end_time - start_time) * 1000.0  ! ms

        print '(A, F8.3, A)', "  Allocation time:     ", alloc_time, " ms"
        print '(A, F8.3, A)', "  Memory used:         ", &
              real(free_before - free_after)/(1024.0*1024.0), " MB"
        print '(A, F8.3, A)', "  Theoretical minimum: ", &
              real(2 * BYTES_PER_BUFFER + 2 * BATCH_SIZE * 4)/(1024.0*1024.0), " MB"

        ! Verify GPU can access
        !$cuf kernel do(2) <<<*, *>>>
        do j = 1, FEATURE_SIZE
            do i = 1, BATCH_SIZE
                buffer_a(j, i) = 1.0
                buffer_b(j, i) = 2.0
            end do
        end do

        !$cuf kernel do <<<*, *>>>
        do i = 1, BATCH_SIZE
            labels_a(i) = i
            labels_b(i) = i + BATCH_SIZE
        end do

        istat = cudaDeviceSynchronize()

        if (buffer_a(1, 1) == 1.0 .and. buffer_b(1, 1) == 2.0) then
            print *, "  GPU access:          PASS"
        else
            print *, "  GPU access:          FAIL"
        endif

        deallocate(buffer_a, buffer_b, labels_a, labels_b)
        print *, "  Status:              PASS"
    end subroutine test_managed_allocation

    subroutine test_device_allocation()
        real(4), device, allocatable :: buffer_a(:,:)
        real(4), device, allocatable :: buffer_b(:,:)
        real(8) :: start_time, end_time, alloc_time
        integer :: istat
        integer(8) :: free_before, free_after, total_mem

        print *, "--- Device Memory Allocation (baseline) ---"

        istat = cudaMemGetInfo(free_before, total_mem)

        call cpu_time(start_time)

        allocate(buffer_a(FEATURE_SIZE, BATCH_SIZE), stat=istat)
        allocate(buffer_b(FEATURE_SIZE, BATCH_SIZE), stat=istat)

        call cpu_time(end_time)

        if (istat /= 0) then
            print *, "  FAILED: Allocation error"
            return
        endif

        istat = cudaMemGetInfo(free_after, total_mem)

        alloc_time = (end_time - start_time) * 1000.0

        print '(A, F8.3, A)', "  Allocation time:     ", alloc_time, " ms"
        print '(A, F8.3, A)', "  Memory used:         ", &
              real(free_before - free_after)/(1024.0*1024.0), " MB"

        deallocate(buffer_a, buffer_b)
        print *, "  Status:              PASS"
    end subroutine test_device_allocation

    subroutine test_pinned_allocation()
        use iso_c_binding
        real(4), pointer :: buffer_a(:,:)
        real(4), pointer :: buffer_b(:,:)
        type(c_ptr) :: cptr_a, cptr_b
        real(8) :: start_time, end_time, alloc_time
        integer :: istat
        integer(8) :: buffer_bytes

        print *, "--- Pinned Host Memory Allocation ---"

        buffer_bytes = int(FEATURE_SIZE, 8) * int(BATCH_SIZE, 8) * 4

        call cpu_time(start_time)

        istat = cudaMallocHost(cptr_a, buffer_bytes)
        if (istat /= 0) then
            print *, "  FAILED: cudaMallocHost error for buffer_a"
            return
        endif
        call c_f_pointer(cptr_a, buffer_a, [FEATURE_SIZE, BATCH_SIZE])

        istat = cudaMallocHost(cptr_b, buffer_bytes)
        if (istat /= 0) then
            print *, "  FAILED: cudaMallocHost error for buffer_b"
            istat = cudaFreeHost(cptr_a)
            return
        endif
        call c_f_pointer(cptr_b, buffer_b, [FEATURE_SIZE, BATCH_SIZE])

        call cpu_time(end_time)

        alloc_time = (end_time - start_time) * 1000.0

        print '(A, F8.3, A)', "  Allocation time:     ", alloc_time, " ms"
        print '(A, F8.3, A)', "  Memory allocated:    ", &
              real(2 * buffer_bytes)/(1024.0*1024.0), " MB"

        ! Verify host can write
        buffer_a(1, 1) = 42.0
        buffer_b(1, 1) = 43.0

        if (buffer_a(1, 1) == 42.0 .and. buffer_b(1, 1) == 43.0) then
            print *, "  Host access:         PASS"
        else
            print *, "  Host access:         FAIL"
        endif

        istat = cudaFreeHost(cptr_a)
        istat = cudaFreeHost(cptr_b)
        print *, "  Status:              PASS"
    end subroutine test_pinned_allocation

    subroutine test_allocation_cycles()
        real(4), managed, allocatable :: buffer(:,:)
        integer :: i, istat
        integer(8) :: free_start, free_end, total_mem
        real(8) :: start_time, end_time

        print *, "--- Allocation Cycle Stress Test ---"
        print *, "  Running ", NUM_ALLOC_CYCLES, " alloc/dealloc cycles..."

        istat = cudaMemGetInfo(free_start, total_mem)

        call cpu_time(start_time)

        do i = 1, NUM_ALLOC_CYCLES
            allocate(buffer(FEATURE_SIZE, BATCH_SIZE), stat=istat)
            if (istat /= 0) then
                print *, "  FAILED at cycle ", i
                return
            endif

            ! Touch memory to ensure it's actually allocated
            buffer(1, 1) = real(i)

            deallocate(buffer)
        end do

        call cpu_time(end_time)

        istat = cudaMemGetInfo(free_end, total_mem)

        print '(A, F8.3, A)', "  Total time:          ", &
              (end_time - start_time) * 1000.0, " ms"
        print '(A, F8.4, A)', "  Time per cycle:      ", &
              (end_time - start_time) * 1000.0 / NUM_ALLOC_CYCLES, " ms"

        ! Check for memory leak
        if (abs(free_start - free_end) < 1024 * 1024) then  ! Allow 1MB tolerance
            print *, "  Memory leak check:   PASS (no leak detected)"
        else
            print '(A, F8.3, A)', "  Memory leak check:   WARNING (", &
                  real(free_start - free_end)/(1024.0*1024.0), " MB difference)"
        endif

        print *, "  Status:              PASS"
    end subroutine test_allocation_cycles

    subroutine test_double_buffer_pattern()
        ! Simulate the actual double buffer pattern from design doc
        type :: buffer_t
            real(4), managed, allocatable :: data(:,:)
            integer, managed, allocatable :: labels(:)
            logical :: ready
            integer :: batch_idx
        end type buffer_t

        type(buffer_t), target :: buffer_a, buffer_b
        type(buffer_t), pointer :: current_buffer, loading_buffer, temp
        integer :: i, istat, swap_count
        real(8) :: start_time, end_time, swap_time

        print *, "--- Double Buffer Pattern Test ---"

        ! Allocate both buffers
        allocate(buffer_a%data(FEATURE_SIZE, BATCH_SIZE))
        allocate(buffer_a%labels(BATCH_SIZE))
        buffer_a%ready = .false.
        buffer_a%batch_idx = -1

        allocate(buffer_b%data(FEATURE_SIZE, BATCH_SIZE))
        allocate(buffer_b%labels(BATCH_SIZE))
        buffer_b%ready = .false.
        buffer_b%batch_idx = -1

        ! Set up pointers
        current_buffer => buffer_a
        loading_buffer => buffer_b

        print *, "  Buffers allocated successfully"

        ! Test pointer swapping speed
        swap_count = 10000
        call cpu_time(start_time)

        do i = 1, swap_count
            ! Swap pointers
            temp => current_buffer
            current_buffer => loading_buffer
            loading_buffer => temp
        end do

        call cpu_time(end_time)

        swap_time = (end_time - start_time) * 1e9 / swap_count  ! nanoseconds

        print '(A, F8.1, A)', "  Pointer swap time:   ", swap_time, " ns"

        ! Verify swap correctness
        current_buffer => buffer_a
        loading_buffer => buffer_b
        buffer_a%batch_idx = 1
        buffer_b%batch_idx = 2

        ! Swap once
        temp => current_buffer
        current_buffer => loading_buffer
        loading_buffer => temp

        if (current_buffer%batch_idx == 2 .and. loading_buffer%batch_idx == 1) then
            print *, "  Swap correctness:    PASS"
        else
            print *, "  Swap correctness:    FAIL"
        endif

        ! Cleanup
        deallocate(buffer_a%data, buffer_a%labels)
        deallocate(buffer_b%data, buffer_b%labels)

        print *, "  Status:              PASS"
    end subroutine test_double_buffer_pattern

end program test_02_buffer_allocation
